---
layout: default
---

# 企画開発部 第二回

## 目次

- [条件分岐](#条件分岐)
- [if文](#if文)
- [反復処理](#反復処理)
- [while文](#while文)
- [for文](#for文)

<br />

## 条件分岐

今回は、

- ある条件を満たす時だけ特定の処理をする。
- 条件を満たす間、特定の処理を繰り返す

を実現する方法を試してみます。

<br />

## if文

#### 真理値を表す型 bool

プログラミングでは様々な場面で真理値(真(True)、偽(False))を扱いたくなる場面があります。例えば、スーパーマリオを再現したゲームを作ろうとすると以下のような場面にでくわします。
- タイムがまだ残っているか？残り時間が $0$ 秒になったのならゲームオーバにしないといけない
- マリオがクリボーに接触しているか？しているならマリオにダメージを与えないといけない
    - マリオが大人マリオやファイヤーマリオなら元のマリオに戻す(マリオは今ダメージを受けても耐えられる状態か？）
    - マリオがスター状態ならダメージを与えない(マリオは今無敵か？)
- Pスイッチが押されている状態か？押されているならコインとブロックを逆転しないといけない。専用のBGMを流す必要もある

これらの例は全て真か偽で表現できることがわかります。

`C++`においては、このような真理値を扱うのに`bool`という型が有用です。
- 型というのは、データの種類・扱われ方のことでしたね。

以下のコードを試してみましょう。

```cpp
#include <iostream>

int main() {
    bool true_value = true;
    bool false_value = false;
    std::cout << true_value << std::endl;
    std::cout << false_value << std::endl;
    return 0;
}
```

`bool`値のリテラル[^1] に`true`と`false`があります。それぞれ真、偽を表します。

出力結果は
```txt
1
0
```
となっているはずです。`bool`型を`std::cout`で出力すると、`true`なら $1$ 、 `false` なら $0$ を出力します。

<br />

#### 比較演算子

数の大小関係や、文字列で辞書順でどちらが前か、このふたつのOOは等しいか異なるかといった関係は真理値で扱えます。

```cpp
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    bool isSame = (a == b);
    std::cout << isSame << std::endl;
    return 0;
}
```

$2$ つの整数を空白区切りで入力してあげてください。入力によって出力が異なると思います。
- 等しい時に $1$ 、異なる時に $0$ を出力すると思います。

C++では、`==`と書くことで左辺と右辺が等しいかを判定できます。(等値演算子[^2])
- 左辺と右辺が等しい時に`true`、そうでない時は`false`と評価されます

他にも以下のような比較演算子があります。(ここにあるのが全てでは無いです)

| 演算子 | trueになる条件 | 注釈 |
| :---: | :---: | :---: |
| < | 左辺が右辺より小さい | 文字や文字列だと、辞書順比較 |
| <= | 左辺が右辺以下か | |
| > | 左辺が右辺より大きい | |
| >= | 左辺が右辺以上 | |
| == | 左辺と右辺が等しい | |
| != | 左辺と右辺が異なる | |


#### if文

以下のサンプルコードを試してみましょう

```cpp
#include <iostream>

int main() {
    std::cout << "整数を入力してください" << std::endl;

    int value;
    std::cin >> value;
    
    if (value % 3 == 0) {
        std::cout << "value is 3k!" << std::endl;
    }
    else if (value % 3 == 1) {
        std::cout << "value is 3k + 1!" << std::endl;
    }
    else {
        std::cout "value is 3k + 2!" << std::endl;
    }

    return 0;
}
```

標準入力を`int`型の変数`value`に記憶して、`value`の $3$ で割ったあまりによって出力結果が変わります。



この行に注目してみてください。

```cpp
if (value % 3 == 0) {
```

この構文は`if`文といって、()の中身の式、値が`true`と評価されるなら波括弧`{}`の中の処理をすることができます。
- 今回は、()の中に`value % e == 0`が入っていますね。`value % 2`は`value`を $3$ で割ったあまりが $0$ の時に $0$ になりますね。
- つまり、`value`が $3$ の倍数の時に左辺と右辺が等しくなって`value % 2 == 0`が`true`と評価されます。

```cpp
else if (value % 3 == 1)
```
直前までの`if`文が`false`で`{}`の中身を評価されなかった時、`else if`文の条件分岐を見ます。この`else if ()`の`()`の中身が`true`ならば`{}`の中身に入って、そうでないならばそのさらに下の`else if`や`else`の条件分岐に移ります。

```cpp
else {
```
一連の`if`、`else if`が全て`false`だっと時に限り、`{}`の中に入ります。それ以外に入ることはありません。

```txt
if () { // 最初の条件分岐
}
else if () { // 上のifがfalseの時
}
else if () { // 上のif、else ifがfalseの時
}
...
else { // 一連のif、else ifがfalseの時

}
```

みたいなルールで条件分岐をします。

#### 注意
- `else if`は`if`文の後に続く。
- `else`文は一連の`if`の最後にしか来ない。

```cpp
これはだめ
else if () {
}
else {
}
```

```cpp
これもだめ
else {
}
if () {
}
```

<br />

#### ちょっと練習

1. ２つの整数を標準入力で受け取って、先に入力した整数が後に入力した整数よりも小さい時に「a < b!」と出力するプログラムを書きましょう
2. `if`文や比較演算子を自由に試してみましょう。

<br />

#### 整数と真理値の関係


整数型(`int`や`long`、`std::int32_t`等)は必要に応じて以下のルールで真理値に変換されます。(例えば`if`文の`()`の中に整数を入れた時)
- $0$ なら `false`
- $0$ でないなら `true`

以下のコードを試してみましょう。

```cpp
#include <iostream>

int main() {
    int val;
    std::cin >> val;
    if (val) {
        std::cout << val << " true" << std::endl;
    }
    else {
        std::cout << val << " false" << std::endl;
    }
    return 0;
}
```

`bool`は反対に`true`なら`1`、`false`なら`0`と変換されることがあります。
- 標準出力の時もそうでしたね。

```cpp
#include <iostream>

int main() {
    bool a = true, b = false, c = true;
    int sum = 0;
    sum += a;
    sum += b;
    sum += c;
    std::cout << sum << std::endl;

    return 0;
}
```

<br />

#### ややこしいクイズ



慣れないと結構ややこしいので、間違えても落ち込まないでください。
- 正解は自分でプログラムを書いて確認してみましょう

1. `false != true`の真理値は？
2. `false < true`の真理値は？
3. `(0 + 1)`の真理値は？
4. `(1 + 1) == true`の真理値は？

<br />

#### 論理演算子

例えば、以下のような状況を考えます。
- 入力した整数が $3$ の倍数だけど $2$ の倍数でないかを判定したい。

これは以下の様に書けます。

```cpp
#include <iostream>

int main() {
    int value;
    std::cin >> value;
    if (value % 3 == 0) {
        if (value % 2 != 0) {
            std::cout << "Yay!" << std::endl;
        }
    }
    return 0;
}
```

しかし、以下のようにも書けます。

```cpp
#include <iostream>

int main() {
    int value;
    std::cin >> value;
    if (value % 3 == 0 and value % 2 != 0) {
        std::cout << "Yay!" << std::endl;
    }
    return 0;
}
```

ここでの`and`とは「かつ」を表す「論理演算子」です。

他の論理演算子も列挙しておきます。

| 論理演算子 | 意味 | 真になる条件 | 他の書き方 |
| :---: | :---: | :---: | :---: |
| and | 論理積 | 右辺がtrueかつ左辺がtrue | && |
| or | 論理和 | 右辺または左辺の少なくとも一方がtrue | \|\| |
| not | 否定 | 直後の真理値がfalseの時 | ! |

`not`だけ二項演算でないことに注意してください。

#### 例

```
#include <iostream>

int main() {
    int a = 100, b = 100;
    if (a == 100 and b == 100) {
        std::cout << "and" << std::endl;
    }
    
    if (a == 100 or b == 100 {
        std::cout << "or" << std::endl;
    }

    if (not (a == 100)) { // ここは出力されない
        std::cout << "not" << std::endl;
    }

    return 0;
}
```

#### 短絡評価

知らなくてもプログラムは書けますが、ゲームに関わらず様々なプログラムでロジックを組む時に重要なので紹介しておきます。

CやC++、Pythonで`and`、`or`(他言語なら、それと同じ意味の演算)では短絡評価というものがなされます。

超大雑把にいうと、「左辺で結果がわかるなら右辺を評価しない」です。

例

```cpp
#include <iostream>

int main() {
    int a = 10;
    if (a == 10 or a == 9) {
        std::cout << "Yay!" << std::endl;
    }
    if (a == 9 and a == 10) {
        std::cout << "Yay!" << std::endl;
    }
    return 0;
}
```

ひとつめの`if`文の()の中には`a == 10 or a == 9`が入っていますが、`a == 10`を見た時点でこの()内の式全体が`true`であることがわかります。なので、プログラムは`a == 9`という判定をせずに、`{}`内の処理(`std::cout << "Yay!" << std::endl;`)をします。

ふたつめの`if`文の()の中には`a == 0 and a == 10`が入っていますが、`a == 9`を見た時点でこの()内の式全体が`false`であることがわかります。なので、プログラムは`a == 10`という判定をせずに、次の処理へ進みます。

<br />

## 反復処理

ここまでで、条件分岐(ある特定の条件を満たす時に限り特定の処理を行う)のしかたを学びました。次に反復処理(ある条件を満たし続ける限り、特定の処理を繰り返す)を学びます。
- この対応関係からわかる通り、反復処理を理解するには条件分岐の理解が必須です。資料の内容が理解できないと感じたら一旦条件分岐のパートから理解し直してみましょう。

<br />

## while文

#### while文の文法

`while`文は`if`文と同じように、ある特定の条件を満たす時だけ処理を行います。しかし、一度処理を行った後も条件の判定を行い、条件式が真である限り処理を行います。

例

```cpp
#include <iostream>

int main() {
    int val = 3;
    while (val > 0) {
        cout << val << endl;
        val--;
    }
    return 0;
}
```

`while () {}`の`()`の中身に条件式を書きます(`if`文と同じですね)。そして、この`val > 0`が真である限り`{}`の中身を実行します。

第一回勉強会でちらっとこのようなことを言いました。
- 「プログラムは原則`main`関数内を**上から1行ずつ**実行します」

この原則を念頭に起きながら、このサンプルコードのロジックを紐解いてみましょう。

最初に、変数`val`が用意されて、 $3$ で初期化しています。

次に、`while`文が登場します。条件式`val > 0`が真なので、`{}`の中身を実行します。
- `val`の中身、すなわち $3$ が出力されます。
- `val--`としています。これは「デクリメント」と言って、`val -= 1`と等価です。つまり、`val = val - 1`なので、`val`の値を減算していることがわかります。
 　- これで現在の`val`の値は $2$ になります。
   - 逆に $1$ を足す 「インクリメント」といわれる演算も存在して、これは`val++`とします。


ここで、もう一回`while`文の先頭に戻ります。条件式`val > 0`が真なので、`{}`の中身を実行します。
- `val`の中身、すなわち $2$ が出力されます。
- `val--`で`val`の値が $1$ 減算され、`val`の中身が $1$ になります。


ここで、またまた`while`文の先頭に戻ります。条件式`val > 0`が真なので、`{}`の中身を実行します。
- `val`の中身、すなわち $1$ が出力されます。
- `val--`で`val`の値が $1$ 減算され、`val`の中身が $0$ になります。

また、`while` 文の先頭に戻ります。条件式`val > 0`が偽なので、ループを抜けます。

`return 0`より、プログラムの実行を終了します。

#### ちょっと練習
```
1
2
3
4
5
```

と出力するプログラムを作成してください。


#### continue

上のちょっと練習を応用して、 次のテキストと同じ出力をするプログラムを書こうと考えます。
```
1
2
3
5
6
7
8
10
```

不吉(?)な数と言われている $4$ と $9$ が省かれています。このような時は２つのやり方があります。

一つは`if`文で出力するかしないかをコントロールします。

```cpp
#include <iostream>

int main() {
    int value = 1;
    while (value <= 10) {
        if (value != 4 and value != 9) {
            std::cout << value << std::endl;
        }
        value++;
    }
    return 0;
}
```

もう一つは、`continue`を使う方法です。

```cpp
#include <iostream>

int main() {
    int value = 0;
    while (value < 10) {
        value++;
        if (value == 4 or value == 9) {
            continue;
        } 
        std::cout << value << std::endl;
    }
    return 0;
}
```

`continue`を使うと、`while`ループや`for`ループ(後述)でそれ以後の評価をせずにループの一番上(条件の判定)に戻ります。


#### 2重ループ

次の問題を考えます。

正整数 $L, R$ を標準入力で与えます。 $L$ 以上 $R$ 以下の素数を列挙してください。

これは以下のようなプログラムをかけば正解です。詳しい挙動はコメントを参照してください。

```cpp
#include <iostream>

int main() {
    int L, R;
    std::cin >> L >> R;
    int value = L;
    while (value <= R) { // R以下ならループする。
        bool ok = true;
        int div = value - 1; // 2以上value - 1以下の数で割り切れないかをチェックする
        while (div > 1) {
            if (value % div == 0) { // 割り切れたらだめ
                ok = false;
            }
            div--;
        }
        if (ok) { // okならば、素数なので出力する
            std::cout << value << ' ';
        }
        value++;
    }
    std::cout << std::endl;
    return 0;
}
```

このようにループは入れ子にすることが可能です。

#### break文

次の問題を考えます。

正整数 $N$ を標準入力で与えます。 $N$ 以上の最小の素数を発見してください。

先程と似た問題ですが、今度は $R$ 以下というような指定が無く、上のサンプルコードでいう「外側のループ」をどこまで回せばいいか不明瞭です。


このような時は`break`文が有効です[^3]。

```cpp
#include <iostream>

int main() {
    int N;
    std::cin >> N;
    while (true) { 
        bool ok = true;
        int div = value - 1; // 2以上value - 1以下の数で割り切れないかをチェックする
        while (div > 1) {
            if (value % div == 0) { // 割り切れたらだめ
                ok = false;
            }
            div--;
        }
        if (ok) { // okならば、素数なので出力する
            std::cout << value << std::endl;
            break; // 素数を発見したので、ループから抜ける。jJ:w
        }
        value++;
    }
    return 0;
}
```

`break`を読むと、現在のループから即座に抜けます。

#### 無限ループ

上のサンプルコードで地味に
```cpp
while (true) {
}
```
ということをしています。これは条件式が常に`true`なので、ループの中でループから抜け出す策を講じないと永遠にループをぐるぐるしてしまい、プログラムが終了しなくなってしまいます。
- ここでいう策とは、例えば`break`、`return 0`等です。

このような無限ループの他にも、ロジックの記述を失敗して永遠に条件式が`true`になってしまってプログラムが終了しないなんてことがあります。

もしこれからのプログラミングで、プログラムの実行が終了しないなんてことが発生したら、永遠にループをしていないか確認してみましょう。
- 無限ループの他にも、「標準入力でデータを渡していない」等も考えられますね。


## for文

サンプル問題では、「 $L$ 以上 $R$ 以下である限りループする」みたいなロジックがありました。このような場合は`while`文よりも`for`文の方がスッキリ書けます。

例えば以下の問題を考えましょう。

正整数 $L, R$ を与えます。 $L$ 以上 $R$ 以下の正整数を出力してください。

`for`文を使って書くと、以下のとおりになります。

```cpp
#include <iostream>

int main() {
    int L, R;
    std::cin >> L >> R;
    for (int i = L ; i <= R ; i++) {
        std::cout << i << ' ';
    }
    std::cout << std::endl;
    return 0;
}
```

`for`文は、以下のように書きます。

```
for ( 初めてループに入った時にすること ; 反復する条件 ; ループの一番下まで来て、次ループの上に戻る時にすること ) {
    ループ
}
```

上のサンプルコードで、 $L = 3, R = 6$ を入力した時の挙動を確認してみましょう。(メモ: ホワイトボードに書く)

#### カウンタ変数

上のサンプルコードでいう $i$ のような役割をする変数をしばしばカウンタ変数といいます。
- 慣例的に、 $i, j, k, l, \dots, $ という変数名をつけることがメジャーです。

```cpp
for (int i = 0 ; ~~ ; ~~) {
    for (int j = 0 ; ~~ ; ~~) {
        for (int k = 0 ; ~~ ; ~~ ) {
```

#### 注意ポイント

`for ( ここ ; ; )` で宣言した変数は、`for`文の外側で使用することができません。

他にも

```
for ( ; ; ) {
    ここ
}
```

```
while () {
    ここ
}
```

で宣言した変数は、`for`や`while`の外側で使うことはできません。これは「スコープ」という大切な概念なのですが、次回勉強会に回します。


#### 多重ループでのcontinue, break

ちょっと補足的な内容です。

```cpp
for (int i = 0 ; i < 10 ; i++) {
    for (int j = 0 ; j < 10 ; j++) {
        break;
    }
}
```

この`break`は、内側の`j`のループから抜けるだけで、`i`のループからは抜けません。

#### ちょっと練習

`for`文、`while`文で遊んでみてください。
- 特にネタが思いつかない人は、今までのサンプルコードをコピペせずに書いて挙動を目で追ってみてください。


[^1]: 数値や文字の並びを直接プログラムに書いたものをリテラルと呼びます。例えば、"Hello World"は文字列リテラル。'a'は文字リテラル。 $1333$ は整数リテラルです。他にも沢山の種類のリテラルがあります。

[^2]: リファレンスによって「等価演算子」と言われている時もあれば「等値演算子」と言われている時もあってヤバイ！！！。規格書は「equal to」と言っているので等値だと思います。

[^3]: 実はbreakを使わなくても解けます。考えてみてね
